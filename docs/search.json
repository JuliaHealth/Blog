[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nWelcome to the JuliaHealthBlog! üëã\n\n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n\n\n\n\n\n\n\n\n\n\nGSoC ‚Äô24: Enhancements to KomaMRI.jl GPU Support\n\n\n\n\n\nA summary of my project for Google Summer of Code\n\n\n\n\n\nAug 30, 2024\n\n\nRyan Kierulf\n\n\n15 min\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC ‚Äô24: IPUMS.jl Small Project\n\n\n\n\n\nA summary of my project for Google Summer of Code\n\n\n\n\n\nAug 26, 2024\n\n\nMichela Rocchetti\n\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\n\nDummy Post\n\n\n\n\n\nPost description\n\n\n\n\n\nJun 22, 2024\n\n\nFoobar\n\n\n1 min\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "posts/michela-gsoc/Michela_JSoC.html",
    "href": "posts/michela-gsoc/Michela_JSoC.html",
    "title": "GSoC ‚Äô24: IPUMS.jl Small Project",
    "section": "",
    "text": "Hello! üëã\nHi! I am Michela, I have a Master‚Äôs degree in Physics of Complex Systems and I am currently working as a software engineer in Rome, where I am from. During my studies, I became interested in the use of modeling and AI methods to improve healthcare and how these tools can be used to better understand how cultural and social backgrounds influence the health of individuals. I am also interested in the computational modeling of the brain and the human body and its implications for a better understanding of certain pathological conditions.\nWith these motivations in mind, I heard about Google Summer of Code. Since I had studied Julia in some courses and given that the language is expanding rapidly, I decided to find a project within Julia. As a result, I found the project of Jacob Zelko (@TheCedarPrince) to start this experience.\n\nIf you want to learn more about me, you can connect with me here: LinkedIn, GitHub\n\n\n\nProject Description\nIPUMS is the ‚Äúworld‚Äôs largest available single database of census microdata‚Äù, providing survey and census data from around the world. It includes several projects that provide a wide variety of datasets. The information and data collected by IPUMS are useful for comparative research, as well as for the analysis of individuals in their life contexts. These data can be used to create a more comprehensive dataset that will facilitate research on the social determinants of health for different types of diseases, social communities, and geographical areas.\n\n\nTo learn more about IPUMS, visit the website\n\n\n\nTasks and Goals\nThe primary objectives of this proposal are to:\n\nDevelop a native Julia package to interact with the APIs available around the datasets IPUMS provides.\nProvide useful utilities within this package for manipulating IPUMS datasets.\nCompose this package with the wider Julia ecosystem to enable novel research in health, economics, and more.\n\nTo achieve this, the work was distributed as follows:\n\nExpand some of the functionality developed in ipumsr IPUMS NHGIS\n\nCreate a link between OpenAPI documentation and the functions internally used in IPUMS.jl: updating already present functions, determining if updating is needed, and testing them\nDevelop functionality similar to the get_metadata_nghis function present in ipumsr\n\nUpdate IPUMS documentation\n\nSet up and deploy DocumenterVitepress.jl\n\nWrite a blog post on how IPUMS.jl can be composed within the ecosystem.\n\n\n\n\nHow the work was done\nThe first task was to migrate documents from Documenter to DocumenterVitepress.This issue aims to support the significant refactoring underway across JuliaHealth, aimed at improving the discoverability and cohesion of the JuliaHealth ecosystem, particularly about documentation. This issue is intended to create a more attractive entry point for new Julia users interested in health research within the Julia community. To accomplish this task, a dependency of DocumenterVitepress was added to the docs directory of the IPUMS.jl repository. Once this was done, the Documenter.jl make.jl file was migrated into a DocumenterVitepress.jl make.jl file. Working on the make.jl file, the pages structure were added to the web page explaining the IPUMS.jl package. With this in mind, those were added: 1. Home: to explain the main purpose of the package 2. Workflows: to explain the working process 3. How to: to give general information 4. Tutorials: to show how to use IPUMS.jl\n5. Examples: some examples of activities 6. Mission: to explain why the package is useful for the community 7. References: references used to write the pages.\nThis first task takes some time, especially setting up GitHub and cloning the repository locally. At this point, my experience with GitHub was really limited and I had to learn how to use the Git environment from scratch, for example how to do continuous integration (to commit code to a shared repository), documentation release and merge, and local testing. I found the support of my mentors and searching for material online was really helpful.\nThe second task was to update the documentation of IPUMS.jl by modifying the functionality within the model folder in the IPUMS.jl folder. The main aim of this task was to a description of the function and its attributes, an example of possible implementation and result, and finally to show how to use it. The documentation to be updated as of several types of functions: 1. Data extract 2. Data set 3. Data Table 4. Time series table 5. Error 6. Shapefile. Each of these macro-categories (from 1 to 4) contains a set of functions, each signaling the different expected output and specific purpose. Information about what each function does, and the meaning of each specific input variable, has been found on the IPUMS website and references have been made in the written documentation.\n\n\nHow to work with IPUMS\nAfter writing down the description of the function and the inputs, examples were formulated, starting from the IPUMS website: when you register at IPUMS, an API key is given. which is used, among other things, to run pre-written code on the website. This code contains examples of these functions, and these examples have been adapted by changing some input values and adapting them to work in the Julia framework. The latter task was done by simply rewriting some structures, such as dictionaries, maps, or lists, in the Julia language. Here is a small guide on how to set up working with the API: 1. Create an IPUMS account 2. Log in to your account 3. Copy the API key, which can be obtained from the website 4. Use the key to run the code that is already available on the IPUMS Developer Portal, where you will also find information about the variables and packages.\n\n\nFunctions testing\nA final task was to test the functions in the ‚Äòapi_IPUMSAPI.jl‚Äô file. In this file, the function to be tested and other functions are defined and the most important ones are extracted to be available in the available throughout the framework. Some of the functions to be tested were the following:\n\nmetadata_nhgis_data_tables_get\nmetadata_nhgis_datasets_dataset_data_tables_data_table_get\nmetadata_nhgis_datasets_dataset_get\nmetadata_nhgis_datasets_get\n\nBefore working on the Julia files, testing and understanding the original R function was done using R studio.\n\nEach function was then tested using the API key from the IPUMS registration as well as other input examples taken from the documentation or the IPUMS website. or from the IPUMS website. All functions were displayed successfully, giving the expected result, so it can be concluded that the translation from R to Julia is successful.\n\n\nCode\nusing IPUMS\nusing OpenAPI\n\napi_key = \"insert your key here\"\n\nversion = \"2\"\npage_number = 1\npage_size = 2500\n#media_type = \n\napi = IPUMSAPI(\"https://api.ipums.org\", Dict(\"Authorization\" =&gt; api_key));\n\nres1 = metadata_nhgis_data_tables_get(api, version)\n\nres2 = metadata_nhgis_datasets_dataset_get(api, \"2022_ACS1\", \"2\");\n\nres3 = metadata_nhgis_datasets_dataset_data_tables_data_table_get(api, \"2022_ACS1\",\"B01001\", \"2\");\n\nres4 = metadata_nhgis_datasets_get(api, \"2\");\n\n\nAn example of the output is:\n. . .\n\n{\n  \"name\": \"NT1\",\n  \"nhgisCode\": \"AAA\",\n  \"description\": \"Total Population\",\n  \"universe\": \"Persons\",\n  \"sequence\": 1,\n  \"datasetName\": \"1790_cPop\",\n  \"nVariables\": [\n    1\n  ]\n}\n\n. . .\n\n\nAccomplished Goals and Future Development\nThe project was a 90-hour small project and during this time the documentation was completed and the testing of the metadata function was done, as well as the migration from Documenter.jl to DocumenterVitepress.jl. During these months some things took longer than I expected because of some problems that occurred, so some things were missing in relation to the original plan. However, this time was useful for learning new things: - I saw how to work with a package under development, how to work with large datasets, and how to write documentation - I had the opportunity to better understand how to work with Git and GitHub - I learned some new things about R, which was a completely unknown language to me. - I deepened my knowledge of Julia, a language I had worked with during my time at university. - I had the chance to work on a large open-source project, to be part of a large community, and to learn how to communicate with it efficiently.\nA special thanks goes to my mentors, Jacob Zelko and Krishna Bhogaonker, for helping me through this process.\nFuture developments of this work could include deepening the work that my mentors and I have started, with the possibility of integrating this package with other machine learning packages in Julia and, from there, doing new analyses of the data in terms of social and geographical implications for health.\n\n\n\n\n\n\n Back to topCitationBibTeX citation:@online{rocchetti2024,\n  author = {Rocchetti, Michela},\n  title = {GSoC ‚Äô24: {IPUMS.jl} {Small} {Project}},\n  date = {2024-08-26},\n  url = {https://juliahealth.org/JuliaHealthBlog/posts/michela-gsoc/Michela_JSoC.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nRocchetti, Michela. 2024. ‚ÄúGSoC ‚Äô24: IPUMS.jl Small\nProject.‚Äù August 26, 2024. https://juliahealth.org/JuliaHealthBlog/posts/michela-gsoc/Michela_JSoC.html."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/dummy/index.html",
    "href": "posts/dummy/index.html",
    "title": "Dummy Post",
    "section": "",
    "text": "Seciton 1\nSmall dummy blog post\n\n\nCode\n2 + 2\n\n\n4\n\n\n\n\nCode\nprintln(2 + 2)\n\n\n4\n\n\n\n\nSection 2\n\n\nSection 3\n\n\n\n\n\n\n Back to topCitationBibTeX citation:@online{2024,\n  author = {, Foobar},\n  title = {Dummy {Post}},\n  date = {2024-06-22},\n  url = {https://juliahealth.org/JuliaHealthBlog/posts/dummy/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nFoobar. 2024. ‚ÄúDummy Post.‚Äù June 22, 2024. https://juliahealth.org/JuliaHealthBlog/posts/dummy/."
  },
  {
    "objectID": "posts/ryan-gsoc/Ryan_GSOC.html",
    "href": "posts/ryan-gsoc/Ryan_GSOC.html",
    "title": "GSoC ‚Äô24: Enhancements to KomaMRI.jl GPU Support",
    "section": "",
    "text": "Hi! üëã\nI am Ryan, an MS student currently studying computer science at the University of Wisconsin-Madison. Looking for a project to work on this summer, my interest in high-performance computing and affinity for the Julia programming language drew me to Google Summer of Code, where I learned about this project opportunity to work on enhancing GPU support for KomaMRI.jl.\nIn this post, I‚Äôd like to summarize what I did this summer and everything I learned along the way!\n\nIf you want to learn more about me, you can connect with me here: LinkedIn, GitHub\n\n\n\nWhat is KomaMRI?\nKomaMRI is a Julia package for efficiently simulating Magnetic Resonance Imaging (MRI) acquisitions. MRI simulation is a useful tool for researchers, as it allows testing new pulse sequences to analyze the signal output and image reconstruction quality without needing to actually take an MRI, which may be time or cost-prohibitive.\nIn contrast to many other MRI simulators, KomaMRI.jl is open-source, cross-platform, and comes with an intuitive user interface (To learn more about KomaMRI, you can read the paper introducing it here). However, being developed fairly recently, there are still new features that can be added and optimization to be done.\n\n\nProject Goals\nThe goals outlined by Carlos (my project mentor) and I the beginning of this summer were:\n\nExtend GPU support beyond CUDA to include AMD, Intel, and Apple Silicon GPUs, through the packages AMDGPU.jl, oneAPI.jl, and Metal.jl\nCreate a CI pipeline to be able to test each of the GPU backends\nCreate a new kernel-based simulation method optimized for the GPU, which we expected would outperform array broadcasting\n(Stretch Goal) Look into ways to support running distributed simulations across multiple nodes or GPUs\n\n\n\nStep 1: Support for Different GPU backends\nPreviously, KomaMRI‚Äôs support for GPU acceleration worked by converting each array used within the simulation to a CuArray, the device array type defined in CUDA.jl. This was done through a general gpu function. The inner simulation code is GPU-agnostic, as the same operations can be performed on a CuArray or a plain CPU Array. This approach is good for extensibility, as it does not require writing different simulation code for the CPU / GPU, or different GPU backends, and would only work in a language like Julia based on runtime dispatch!\nTo extend this to multiple GPU backends, all that is needed is to generalize the gpu function to convert to either the device types of CUDA.jl, AMDGPU.jl, Metal.jl, or oneAPI.jl, depending on which backend is being used. To give an idea of what the gpu conversion code looked like before, here is a snippet:\nstruct KomaCUDAAdaptor end\nadapt_storage(to::KomaCUDAAdaptor, x) = CUDA.cu(x)\n\nfunction gpu(x)\n    check_use_cuda()\n    return use_cuda[] ? fmap(x -&gt; adapt(KomaCUDAAdaptor(), x), x; exclude=_isleaf) : x\nend\n\n#CPU adaptor\nstruct KomaCPUAdaptor end\nadapt_storage(to::KomaCPUAdaptor, x::AbstractArray) = adapt(Array, x)\nadapt_storage(to::KomaCPUAdaptor, x::AbstractRange) = x\n\ncpu(x) = fmap(x -&gt; adapt(KomaCPUAdaptor(), x), x)\nThe fmap function is from the package Functors.jl and can recursively apply a function to a struct tagged with @functor. The function being applied is adapt from Adapt.jl, which will call the lower-level adapt_storage function to actually convert to / from the device type. The second parameter to adapt is what is being adapted, and the first is what it is being adapted to, which in this case is a custom adapter struct KomaCUDAAdapter.\nOne possible approach to generalize to different backends would be to define additional adapter structs for each backend and corresponding adapt_storage functions. This is what the popular machine learning library Flux.jl does. However, there is a simpler way!\nEach backend package (CUDA.jl, Metal.jl, etc.) already defines adapt_storage functions for converting different types to / from corresponding device type. Reusing these functions is preferable to defining our own since, not only does it save work, but it allows us to rely on the expertise of the developers who wrote those packages! If there is an issue with types being converted incorrectly that is fixed in one of those packages, then we would not need to update our code to get this fix since we are using the definitions they created.\nOur final gpu and cpu functions are very simple. The backend parameter is a type derived from the abstract Backend type of KernelAbstractions.jl, which is extended by each of the backend packages:\nimport KernelAbstractions as KA\n\nfunction gpu(x, backend::KA.GPU)\n    return fmap(x -&gt; adapt(backend, x), x; exclude=_isleaf)\nend\n\ncpu(x) = fmap(x -&gt; adapt(KA.CPU(), x), x, exclude=_isleaf)\nThe other work needed to generalize our GPU support involved switching to use package extensions to avoid having each of the backend packages as an explicit dependency, and defining some basic GPU functions for backend selection and printing information about available GPU devices. The pull request for adding support for multiple backends is linked below:\n\nhttps://github.com/JuliaHealth/KomaMRI.jl/pull/405\n\n\n\nStep 2: Buildkite CI\nAt the time the above pull request was merged, we weren‚Äôt sure whether the added support for AMD and Intel GPUs actually worked, since we only had access to CUDA and Apple Silicon GPUs. So the next step was to set up a CI to test each GPU backend. To do this, we used Buildkite, which is a CI platform that many other Julia packages also use. Since there were many examples to follow, setting up our testing pipeline was not too difficult. Each step of the pipeline does the required environment setup and then calls Pkg.test() for KomaMRICore. As an example, here is what the AMDGPU step of our pipeline looks like:\n      - label: \"AMDGPU: Run tests on v{{matrix.version}}\"\n        matrix:\n          setup:\n            version:\n              - \"1\"\n        plugins:\n          - JuliaCI/julia#v1:\n              version: \"{{matrix.version}}\"\n          - JuliaCI/julia-coverage#v1:\n              codecov: true\n              dirs:\n                - KomaMRICore/src\n                - KomaMRICore/ext\n        command: |\n          julia -e 'println(\"--- :julia: Instantiating project\")\n              using Pkg\n              Pkg.develop([\n                  PackageSpec(path=pwd(), subdir=\"KomaMRIBase\"),\n                  PackageSpec(path=pwd(), subdir=\"KomaMRICore\"),\n              ])'\n          \n          julia --project=KomaMRICore/test -e 'println(\"--- :julia: Add AMDGPU to test environment\")\n              using Pkg\n              Pkg.add(\"AMDGPU\")'\n          \n          julia -e 'println(\"--- :julia: Running tests\")\n              using Pkg\n              Pkg.test(\"KomaMRICore\"; coverage=true, test_args=[\"AMDGPU\"])'\n        agents:\n          queue: \"juliagpu\"\n          rocm: \"*\"\n        timeout_in_minutes: 60\nWe also decided that in addition to a testing CI, it would also be helpful to have a benchmarking CI to track performance changes resulting from each commit to the main branch of the repository. Lux.jl had a very nice-looking benchmarking page, so I decided to look into their approach. They were using github-action-benchmark, a popular benchmarking action that integrates with the Julia package BenchmarkTools.jl. github-action-benchmark does two very useful things:\n\nCollects benchmarking data into a json file and provides a default index.html to display this data. If put inside a relative path in the gh-pages branch of a repository, this results in a public benchmarking page which is automatically updated after each commit!\nComments on a pull request with the benchmarking results compared with before the pull request. Example: https://github.com/JuliaHealth/KomaMRI.jl/pull/442#pullrequestreview-2213921334\n\nThe only issue was that since github-action-benchmark is a github action, it is meant to be run within github by one of the available github runners. While this works for CPU benchmarking, only Buildkite has the CI setup for each of the GPU backends we are using, and Lux.jl‚Äôs benchmarks page only included CPU benchmarks, not GPU benchmarks (Note: we talked with Avik, the repository owner of Lux.jl, and Lux.jl has since adopted the approach outlined below to display GPU and CPU benchmarks together). I was not able to find any examples of other julia packages using github-action-benchmark for GPU benchmarking.\nFortunately, there is a tool someone developed to download results from Buildkite into a github action (https://github.com/EnricoMi/download-buildkite-artifact-action). This repository only had 1 star when I found it, but it does exactly what we needed: it identifies the corresponding Buildkite build for a commit, waits for it to finish, and then downloads the artifacts for the build into the github action it is being run from. With this, we were able to download the Buildkite benchmark results from a final aggregation step into our benchmarking action and upload to github-action-benchmark to publish to either the main data.js file for our benchmarking website, or pull request.\nOur final benchmarking page looks like this and is publicly accessible:\n\nOne neat thing about github-action-benchmark is that the default index.html is extensible, so even though by deault it only shows time, the information for memory usage and number of allocations is also collected into the json file, and can be displayed as well.\nA successful CI run on Buildkite Looks like this:\n\nThe pull requests for creating the CI testing and benchmarking pipeline, and changing the index.html for our benchmark page are listed below:\n\nhttps://github.com/JuliaHealth/KomaMRI.jl/pull/411\nhttps://github.com/JuliaHealth/KomaMRI.jl/pull/418\nhttps://github.com/JuliaHealth/KomaMRI.jl/pull/421\n\n\n\nStep 3: Optimization\nWith support for multiple backends enabled, and a robust CI, the next step was to optimize our simulation code as much as possible. Our original idea was to create a new GPU-optimized simulation method, but before doing this we wanted to look more at the existing code and optimize for the CPU.\nThe simulation code is solving a differential equation (the [Bloch equations(https://en.wikipedia.org/wiki/Bloch_equations)]) over time. Most differential equation solvers step through time, updating the current state at each time step, but our previous simulation code, more optimized for the GPU, did a lot of computations across all time points in a simulation block, allocating a matrix of size Nspins by NŒît each time this was done. Although this is beneficial for the GPU, where there are millions of threads available on which to parallelize these computations, for the CPU it is more important to conserve memory, and the aforementioned approach of stepping through time is preferable.\nAfter seeing that this approach did help speed up simulation time on the CPU, but was not faster on the GPU (7x slower for Metal!) we decided to separate our simulation code for the GPU and CPU, dispatching based on the KernelAbstractions.Backend type depending on if it is &lt;:KernelAbstractions.CPU or &lt;:KernelAbstractions.GPU.\nOther things we were able to do to speed up CPU computation time:\n\nPreallocating each array used inside the core simulation code so it can be re-used from one simulation block to the next.\nSkipping an expensive computation if the magnetization at that time point is not added to the final signal\nEnsuring that each statement is fully broadcasted. We were surprised to see the difference between the following examples:\n\n#Fast\nBz = x .* seq.Gx' .+ y .* seq.Gy' .+ z .* seq.Gz' .+ p.Œîw ./ T(2œÄ .* Œ≥)\n\n#Slow\nBz = x .* seq.Gx' .+ y .* seq.Gy' .+ z .* seq.Gz' .+ p.Œîw / T(2œÄ * Œ≥)\n\nUsing the cis function for complex exponentiation, which is faster than exp\n\nWith these changes, the mean improvement in simulation time aggregating across each of our benchmarks for 1, 2, 4, and 8 CPU threads was ~4.28. For 1 thread, the average improvement in memory usage was 90x!\nThe next task was optimizing the simulation code for the GPU. Although our original idea was to put everything into one GPU kernel, we found that the existing broadcasting operations were already very fast, and that custom kernels we wrote were not able to outperform the previous implementation. The Julia GPU compiler team deserves a lot of credit for developing such fast broadcasting implementations!\nHowever, this does not mean that we were unable to improve the GPU simulation time. Similar to with the CPU, preallocation made a substantial difference. Parallelizing as much work as possible across the time points for a simulation block was also found to beneficial. For the parts that needed to be done sequentially, a custom GPU kernel was written which used the KernelAbstractions.@localmem macro for arrays being updated at each time step to yield faster memory access.\nThe mean speedup we saw across the 4 supported GPU backends was 4.16, although this varied accross each backend (for example, CUDA was only 2.66x faster while oneAPI was 28x faster). There is a remaining bottleneck in the run_spin_preceession! function having to do with logical indexing that I was not able to resolve, but could be solved in the future to speed up the GPU simulation time even further!\nThe pull requests optimizing code for the CPU and GPU are below:\n\nhttps://github.com/JuliaHealth/KomaMRI.jl/pull/443\nhttps://github.com/JuliaHealth/KomaMRI.jl/pull/459\nhttps://github.com/JuliaHealth/KomaMRI.jl/pull/462\n\n\n\n4. Step 4: Distributed Support\nThis last step was a stretch goal for exploring how to add distributed support to KomaMRI. MRI simulations can become quite large, so it is useful to be able to distribute work across either multiple GPUs or multiple compute nodes.\nA nice thing about MRI simulation is the independent spin property: if a phantom object (representing, for example a brain tissue slice) is divided into two parts, and each part is simulated separately, the signal result from simulating the whole phantom will be equal to the sum of the signal results from simulating each subdivision of the original phantom. This makes it quite easy to distribute work, either across more than one GPU or accross multiple compute nodes.\nThe following scripts worked, with the only necessary code change to the repository being a new + function to add two RawAcquisitionData structs:\n#Use multiple GPUs:\nusing Distributed\nusing CUDA\n\n#Add workers based on the number of available devices\naddprocs(length(devices()))\n\n#Define inputs on each worker process\n@everywhere begin\n    using KomaMRI, CUDA\n    sys = Scanner()\n    seq = PulseDesigner.EPI_example()\n    obj = brain_phantom2D()\n    #Divide phantom\n    parts = kfoldperm(length(obj), nworkers())\nend\n\n#Distribute simulation across workers\nraw = Distributed.@distributed (+) for i=1:nworkers()\n    KomaMRICore.set_device!(i-1) #Sets device for this worker, note that CUDA devices are indexed from 0\n    simulate(obj[parts[i]], seq, sys)\nend\n#Use multiple compute nodes\nusing Distributed\nusing ClusterManagers\n\n#Add workers based on the specified number of SLURM tasks\naddprocs(SlurmManager(parse(Int, ENV[\"SLURM_NTASKS\"])))\n\n#Define inputs on each worker process\n@everywhere begin\n    using KomaMRI\n    sys = Scanner()\n    seq = PulseDesigner.EPI_example()\n    obj = brain_phantom2D()\n    parts = kfoldperm(length(obj), nworkers())\nend\n\n#Distribute simulation across workers\nraw = Distributed.@distributed (+) for i=1:nworkers()\n    simulate(obj[parts[i]], seq, sys)\nend\nPull reqeust for adding these examples to the KomaMRI documentation: https://github.com/JuliaHealth/KomaMRI.jl/pull/468\n\n\nConclusions / Future Work\nThis project was a 350-hour large project, since there were many goals to accomplish. To summarize what changed since the beginning of the project:\n\nAdded support for AMDGPU.jl, Metal.jl, and oneAPI.jl GPU backends\nCI for automated testing and benchmarking accross each backend + public benchmarks page\nSignificantly faster CPU and GPU performance\nDemonstrated distributed support and examples added in documentation\n\nFuture work could look at ways to further optimize the simulation code, since despite the progress made, I believe there is more work to be done! The aforementioned logical indexing issue is still not resolved, and the kernel used inside the run_spin_excitation! function has not been profiled in depth. KomaMRI is also looking into adding support for higher-order ODE methods, which could require more GPU kernels being written.\n\n\nAcknowledgements\nI would like to thank my mentor, Carlos Castillo, for his help and support on this project. I would also like to thank Jakub Mitura, who attended some of our meetings to help with GPU optimization, Dilum Aluthge who helped set up our BuildKite pipeline, and Tim Besard, who answered many GPU-related questions that Carlos and I had.\n\n\n\n\n\n\n Back to topCitationBibTeX citation:@online{kierulf2024,\n  author = {Kierulf, Ryan},\n  title = {GSoC ‚Äô24: {Enhancements} to {KomaMRI.jl} {GPU} {Support}},\n  date = {2024-08-30},\n  url = {https://juliahealth.org/JuliaHealthBlog/posts/ryan-gsoc/Ryan_GSOC.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nKierulf, Ryan. 2024. ‚ÄúGSoC ‚Äô24: Enhancements to KomaMRI.jl GPU\nSupport.‚Äù August 30, 2024. https://juliahealth.org/JuliaHealthBlog/posts/ryan-gsoc/Ryan_GSOC.html."
  }
]